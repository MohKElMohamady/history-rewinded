// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.7
// source: lear.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LearClient is the client API for Lear service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LearClient interface {
	FetchIncidentsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchIncidentsOnClient, error)
	FetchEventsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchEventsOnClient, error)
	FetchBirthsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchBirthsOnClient, error)
	FetchDeathsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchDeathsOnClient, error)
	FetchHolidaysOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchHolidaysOnClient, error)
}

type learClient struct {
	cc grpc.ClientConnInterface
}

func NewLearClient(cc grpc.ClientConnInterface) LearClient {
	return &learClient{cc}
}

func (c *learClient) FetchIncidentsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchIncidentsOnClient, error) {
	stream, err := c.cc.NewStream(ctx, &Lear_ServiceDesc.Streams[0], "/Lear/FetchIncidentsOn", opts...)
	if err != nil {
		return nil, err
	}
	x := &learFetchIncidentsOnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lear_FetchIncidentsOnClient interface {
	Recv() (*Incident, error)
	grpc.ClientStream
}

type learFetchIncidentsOnClient struct {
	grpc.ClientStream
}

func (x *learFetchIncidentsOnClient) Recv() (*Incident, error) {
	m := new(Incident)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *learClient) FetchEventsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchEventsOnClient, error) {
	stream, err := c.cc.NewStream(ctx, &Lear_ServiceDesc.Streams[1], "/Lear/FetchEventsOn", opts...)
	if err != nil {
		return nil, err
	}
	x := &learFetchEventsOnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lear_FetchEventsOnClient interface {
	Recv() (*Incident, error)
	grpc.ClientStream
}

type learFetchEventsOnClient struct {
	grpc.ClientStream
}

func (x *learFetchEventsOnClient) Recv() (*Incident, error) {
	m := new(Incident)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *learClient) FetchBirthsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchBirthsOnClient, error) {
	stream, err := c.cc.NewStream(ctx, &Lear_ServiceDesc.Streams[2], "/Lear/FetchBirthsOn", opts...)
	if err != nil {
		return nil, err
	}
	x := &learFetchBirthsOnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lear_FetchBirthsOnClient interface {
	Recv() (*Incident, error)
	grpc.ClientStream
}

type learFetchBirthsOnClient struct {
	grpc.ClientStream
}

func (x *learFetchBirthsOnClient) Recv() (*Incident, error) {
	m := new(Incident)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *learClient) FetchDeathsOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchDeathsOnClient, error) {
	stream, err := c.cc.NewStream(ctx, &Lear_ServiceDesc.Streams[3], "/Lear/FetchDeathsOn", opts...)
	if err != nil {
		return nil, err
	}
	x := &learFetchDeathsOnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lear_FetchDeathsOnClient interface {
	Recv() (*Incident, error)
	grpc.ClientStream
}

type learFetchDeathsOnClient struct {
	grpc.ClientStream
}

func (x *learFetchDeathsOnClient) Recv() (*Incident, error) {
	m := new(Incident)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *learClient) FetchHolidaysOn(ctx context.Context, in *FetchIncidentRequest, opts ...grpc.CallOption) (Lear_FetchHolidaysOnClient, error) {
	stream, err := c.cc.NewStream(ctx, &Lear_ServiceDesc.Streams[4], "/Lear/FetchHolidaysOn", opts...)
	if err != nil {
		return nil, err
	}
	x := &learFetchHolidaysOnClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lear_FetchHolidaysOnClient interface {
	Recv() (*Incident, error)
	grpc.ClientStream
}

type learFetchHolidaysOnClient struct {
	grpc.ClientStream
}

func (x *learFetchHolidaysOnClient) Recv() (*Incident, error) {
	m := new(Incident)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LearServer is the server API for Lear service.
// All implementations must embed UnimplementedLearServer
// for forward compatibility
type LearServer interface {
	FetchIncidentsOn(*FetchIncidentRequest, Lear_FetchIncidentsOnServer) error
	FetchEventsOn(*FetchIncidentRequest, Lear_FetchEventsOnServer) error
	FetchBirthsOn(*FetchIncidentRequest, Lear_FetchBirthsOnServer) error
	FetchDeathsOn(*FetchIncidentRequest, Lear_FetchDeathsOnServer) error
	FetchHolidaysOn(*FetchIncidentRequest, Lear_FetchHolidaysOnServer) error
	mustEmbedUnimplementedLearServer()
}

// UnimplementedLearServer must be embedded to have forward compatible implementations.
type UnimplementedLearServer struct {
}

func (UnimplementedLearServer) FetchIncidentsOn(*FetchIncidentRequest, Lear_FetchIncidentsOnServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchIncidentsOn not implemented")
}
func (UnimplementedLearServer) FetchEventsOn(*FetchIncidentRequest, Lear_FetchEventsOnServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchEventsOn not implemented")
}
func (UnimplementedLearServer) FetchBirthsOn(*FetchIncidentRequest, Lear_FetchBirthsOnServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchBirthsOn not implemented")
}
func (UnimplementedLearServer) FetchDeathsOn(*FetchIncidentRequest, Lear_FetchDeathsOnServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchDeathsOn not implemented")
}
func (UnimplementedLearServer) FetchHolidaysOn(*FetchIncidentRequest, Lear_FetchHolidaysOnServer) error {
	return status.Errorf(codes.Unimplemented, "method FetchHolidaysOn not implemented")
}
func (UnimplementedLearServer) mustEmbedUnimplementedLearServer() {}

// UnsafeLearServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LearServer will
// result in compilation errors.
type UnsafeLearServer interface {
	mustEmbedUnimplementedLearServer()
}

func RegisterLearServer(s grpc.ServiceRegistrar, srv LearServer) {
	s.RegisterService(&Lear_ServiceDesc, srv)
}

func _Lear_FetchIncidentsOn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchIncidentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LearServer).FetchIncidentsOn(m, &learFetchIncidentsOnServer{stream})
}

type Lear_FetchIncidentsOnServer interface {
	Send(*Incident) error
	grpc.ServerStream
}

type learFetchIncidentsOnServer struct {
	grpc.ServerStream
}

func (x *learFetchIncidentsOnServer) Send(m *Incident) error {
	return x.ServerStream.SendMsg(m)
}

func _Lear_FetchEventsOn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchIncidentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LearServer).FetchEventsOn(m, &learFetchEventsOnServer{stream})
}

type Lear_FetchEventsOnServer interface {
	Send(*Incident) error
	grpc.ServerStream
}

type learFetchEventsOnServer struct {
	grpc.ServerStream
}

func (x *learFetchEventsOnServer) Send(m *Incident) error {
	return x.ServerStream.SendMsg(m)
}

func _Lear_FetchBirthsOn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchIncidentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LearServer).FetchBirthsOn(m, &learFetchBirthsOnServer{stream})
}

type Lear_FetchBirthsOnServer interface {
	Send(*Incident) error
	grpc.ServerStream
}

type learFetchBirthsOnServer struct {
	grpc.ServerStream
}

func (x *learFetchBirthsOnServer) Send(m *Incident) error {
	return x.ServerStream.SendMsg(m)
}

func _Lear_FetchDeathsOn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchIncidentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LearServer).FetchDeathsOn(m, &learFetchDeathsOnServer{stream})
}

type Lear_FetchDeathsOnServer interface {
	Send(*Incident) error
	grpc.ServerStream
}

type learFetchDeathsOnServer struct {
	grpc.ServerStream
}

func (x *learFetchDeathsOnServer) Send(m *Incident) error {
	return x.ServerStream.SendMsg(m)
}

func _Lear_FetchHolidaysOn_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchIncidentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LearServer).FetchHolidaysOn(m, &learFetchHolidaysOnServer{stream})
}

type Lear_FetchHolidaysOnServer interface {
	Send(*Incident) error
	grpc.ServerStream
}

type learFetchHolidaysOnServer struct {
	grpc.ServerStream
}

func (x *learFetchHolidaysOnServer) Send(m *Incident) error {
	return x.ServerStream.SendMsg(m)
}

// Lear_ServiceDesc is the grpc.ServiceDesc for Lear service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lear_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Lear",
	HandlerType: (*LearServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchIncidentsOn",
			Handler:       _Lear_FetchIncidentsOn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchEventsOn",
			Handler:       _Lear_FetchEventsOn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchBirthsOn",
			Handler:       _Lear_FetchBirthsOn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchDeathsOn",
			Handler:       _Lear_FetchDeathsOn_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchHolidaysOn",
			Handler:       _Lear_FetchHolidaysOn_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lear.proto",
}
